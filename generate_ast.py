#!/usr/bin/env python3

import argparse
import io
import os
import sys
from typing import Dict, List


class LanguageConfig:
    def __init__(self, output_dir: str, extension: str, format_cmd: str):
        self.output_dir = output_dir
        self.extension = extension
        self.format_cmd = format_cmd

        self.expression_output_file_path = os.path.join(
            self.output_dir, f'expression.{self.extension}')

        self.statement_output_file_path = os.path.join(
            self.output_dir, f'statement.{self.extension}')


SUPPORTED_LANGUAGES = {
    'go': LanguageConfig(os.path.join('golox'), 'go', 'gofmt -w'),
}


class ASTDef:
    def __init__(self, name: str, fields: Dict[str, str]):
        self.name = name
        self.fields = fields


EXPRESSIONS = [
    ASTDef('Binary', {
        'left': 'Expression',
        'operator': 'Token',
        'right': 'Expression',
    }),
    ASTDef('Ternary', {
        'condition': 'Expression',
        'true': 'Expression',
        'false': 'Expression',
    }),
    ASTDef('Unary', {
        'operator': 'Token',
        'right': 'Expression',
    }),
    ASTDef('Grouping', {
        'expression': 'Expression',
    }),
    ASTDef('Literal', {
        'value': 'Object',
    }),
]


STATEMENTS = [
    ASTDef('Expression', {
        'expression': 'Expression',
    }),
    ASTDef('Print', {
        'expression': 'Expression',
    }),
]


def generate_go_visitors(type: str, ast_defs: List[ASTDef], f: io.TextIOWrapper):
    # visitor type constraint
    f.write(f"""
type {type}VisitorConstraint interface {{
    string | Value
}}
""")

    # visitor interface
    f.write('\n')
    f.write(f'type {type}Visitor[T {type}VisitorConstraint] interface {{\n')
    for ast_def in ast_defs:
        f.write(
            f'Visit{ast_def.name}{type}({type.lower()} *{ast_def.name}{type}) (T, error)\n')
    f.write('}\n')


def generate_go_definition(type: str, ast_def: ASTDef, f: io.TextIOWrapper):
    # type
    f.write('\n')
    f.write(f'type {ast_def.name}{type} struct {{\n')
    for field_name, field_type in ast_def.fields.items():
        # do some type overriding
        match field_type:
            case 'Object':
                field_type = 'LiteralValue'
            case 'Token':
                field_type = '*Token'
        f.write(f'{field_name.capitalize()} {field_type}\n')
    f.write('}\n')

    # visitor interface
    f.write(
        f'func (e *{ast_def.name}{type}) AcceptString(visitor {type}Visitor[string]) (string, error) {{\n')
    f.write(f'return visitor.Visit{ast_def.name}{type}(e)\n')
    f.write('}\n')
    f.write('\n')
    f.write(
        f'func (e *{ast_def.name}{type}) AcceptValue(visitor {type}Visitor[Value]) (Value, error) {{\n')
    f.write(f'return visitor.Visit{ast_def.name}{type}(e)\n')
    f.write('}\n')


def generate_go_definitions(type: str, file_path: str, defs: List[ASTDef]):
    print(f'Generating Go {type}s to "{file_path}" ...')

    with open(file_path, 'w', encoding='utf-8') as f:
        # header
        f.write('/* This file is autogenerated, DO NOT MODIFY */\n')
        f.write('package main\n')

        # interface
        f.write(f"""
type {type} interface {{
    AcceptString(visitor {type}Visitor[string]) (string, error)
    AcceptValue(visitor {type}Visitor[Value]) (Value, error)
}}
""")

        # definitions
        for d in defs:
            generate_go_definition(type, d, f)

        # visitors
        generate_go_visitors(type, defs, f)

    # format the file
    format_cmd = f'{SUPPORTED_LANGUAGES["go"].format_cmd} {file_path}'
    print(f'Formatting output "{format_cmd}" ...')
    os.system(format_cmd)


def generate_go():
    generate_go_definitions(
        "Expression", SUPPORTED_LANGUAGES['go'].expression_output_file_path, EXPRESSIONS)
    generate_go_definitions(
        "Statement", SUPPORTED_LANGUAGES['go'].statement_output_file_path, STATEMENTS)


def generate(languages: List[str]):
    if 'go' in languages:
        generate_go()


def main(args: argparse.Namespace):
    match args.command:
        case 'generate':
            generate(args.languages)
        case _:
            print(f'Unsupported command: {args.command}')
            sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='AST codegen')

    subparsers = parser.add_subparsers(dest='command', help='sub-command help', required=True)

    subparser = subparsers.add_parser('generate')
    subparser.add_argument('--languages', choices=SUPPORTED_LANGUAGES.keys(), default=SUPPORTED_LANGUAGES.keys(),
                           help='Which languages to generate for')

    args = parser.parse_args()

    main(args)
